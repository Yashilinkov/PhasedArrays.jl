var documenterSearchIndex = {"docs":
[{"location":"#PhasedArrays","page":"Home","title":"PhasedArrays","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for PhasedArrays.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#PhasedArrays.CircularArray","page":"Home","title":"PhasedArrays.CircularArray","text":"CircularArray\n\nCircular aperture array with support for various lattice types.\n\nFields\n\nplane::String: The Cartesian plane in which the circular aperture lies (\"xy\", \"xz\", or \"yz\").\nR::Float64: Radius of the circular aperture in meters.\nN_elements::Int64: Number of antenna elements in the array.\nlattice::LatticeType: Lattice geometry used for placing elements (e.g., Rectangular).\ncoordinates::Matrix{Float64}: A 3×N matrix of element coordinates in 3D space.\nweights::Vector{ComplexF64}: Excitation weights applied to each element.\nelement_pattern::ElementPattern: Radiation pattern model of each element.\n\nDescription\n\nThe CircularArray type represents a 2D array of antenna elements placed within a circular aperture of radius R, lying in the specified Cartesian plane. The layout of elements is controlled by the chosen lattice geometry (currently, only Rectangular is supported). This array type supports arbitrary excitation weights and element radiation patterns.\n\n\n\n\n\n","category":"type"},{"location":"#PhasedArrays.CircularArray-Tuple{String, Float64, LatticeType, Vararg{Any}}","page":"Home","title":"PhasedArrays.CircularArray","text":"CircularArray(plane::String, R::Float64, lattice::LatticeType, args...; kwargs...)\n\nConstruct a circular array of elements within a radius R in the specified Cartesian plane using the specified lattice type.\n\nArguments\n\nplane: Plane in which the array lies (\"xy\", \"xz\", or \"yz\").\nR: Radius of the circular aperture (in meters).\nlattice: Lattice type used for element placement (currently only Rectangular is supported).\nargs..., kwargs...: Passed to the specific lattice constructor (e.g., inter-element spacing, weights, element pattern).\n\nReturns\n\nA CircularArray with coordinates generated based on the chosen lattice type.\n\nExample\n\nf = 3e9\nλ = 3e8 / f\narray = CircularArray(\"xy\", 5λ, Rectangular, 0.5λ, 0.5λ)\n\n\n\n\n\n","category":"method"},{"location":"#PhasedArrays.RingArray","page":"Home","title":"PhasedArrays.RingArray","text":"RingArray(plane::String, radius, N_elements; weights=nothing, pattern=IsotropicPattern('θ'))\n\nConstruct a circular antenna array with N_elements elements equally spaced on a ring of radius radius in the specified plane.\n\nArguments\n\nplane: The Cartesian plane in which the ring lies (\"xy\", \"xz\", or \"yz\").\nradius: Radius of the ring in meters.\nN_elements: Number of antenna elements placed uniformly on the ring.\nweights (optional): Excitation weights for each element; defaults to uniform weights (1/N).\npattern (optional): Element radiation pattern; defaults to an isotropic θ-directed pattern.\n\nReturns\n\nA RingArray instance with 3D element coordinates arranged around the origin.\n\nExample\n\nusing PhasedArrays\nf = 5e9\nλ = 3e8/f\nra = RingArray(\"xy\", λ, 8)\n\n\n\n\n\n","category":"type"},{"location":"#PhasedArrays.RingArray-2","page":"Home","title":"PhasedArrays.RingArray","text":"RingArray\n\nCircular (ring) array of antenna elements in a specified Cartesian plane.\n\nFields\n\nplane::String: The plane in which the ring lies. Must be \"xy\", \"xz\", or \"yz\".\nradius::Float64: Radius of the ring in meters.\nN_elements::Int64: Number of equally spaced elements along the ring.\ncoordinates::Matrix{Float64}: A 3×N matrix of element coordinates in 3D space.\nweights: Complex excitation weights for each element (e.g., a vector of ComplexF64 values).\nelement_pattern::ElementPattern: Radiation pattern model for the array elements (e.g., isotropic or directional).\n\nDescription\n\nThe RingArray type defines a circular array with N_elements evenly spaced antennas placed on a ring of radius radius in the specified plane. It supports arbitrary excitation weights and customizable element radiation patterns.\n\n\n\n\n\n","category":"type"},{"location":"#PhasedArrays.ULA","page":"Home","title":"PhasedArrays.ULA","text":"ULA(axis::Char, N::Int, dist::Float64; weights=nothing, pattern=IsotropicPattern('θ'))\n\nConstruct a Uniform Linear Array along the given axis ('x', 'y', or 'z') with N elements spaced dist meters apart.\n\nWeights and element pattern are optional; defaults are uniform weighting and an isotropic θ-directed pattern.\n\n\n\n\n\n","category":"type"},{"location":"#PhasedArrays.ULA-2","page":"Home","title":"PhasedArrays.ULA","text":"ULA\n\nUniform Linear Array (ULA) of antenna elements.\n\nFields\n\naxis::Char: The axis along which the array is aligned ('x', 'y', or 'z').\nN_elements::Int64: Number of antenna elements in the array.\ndist::Float64: Inter-element spacing in meters.\ncoordinates::Matrix{Float64}: A 3×N matrix of element coordinates in 3D space.\nweights: Complex excitation weights for each element (e.g., a vector of ComplexF64 values).\nelement_pattern::ElementPattern: Radiation pattern model for the array elements (e.g., isotropic or custom pattern).\n\nDescription\n\nThe ULA type defines a uniform linear antenna array with equally spaced elements aligned along a specified Cartesian axis.  The array supports arbitrary excitation weights and element radiation patterns.\n\nExample use:\n\nusing PhasedArrays\nf = 3e9\nλ = 3e8/f\nd = 0.5*λ\nN = 5\nula = ULA('x',N,d)\n\n\n\n\n\n","category":"type"},{"location":"#PhasedArrays.URA","page":"Home","title":"PhasedArrays.URA","text":"URA(plane::String, N1, N2, d1, d2; weights=nothing, pattern=IsotropicPattern('θ'))\n\nConstruct a Uniform Rectangular Array (URA) with N1 × N2 elements spaced by d1 and d2 meters along the specified plane.\n\nArguments\n\nplane: The plane in which the array is placed. Must be \"xy\", \"xz\", or \"yz\".\nN1: Number of elements along the first axis of the chosen plane.\nN2: Number of elements along the second axis of the chosen plane.\nd1: Spacing along the first axis (in meters).\nd2: Spacing along the second axis (in meters).\nweights (optional): Excitation weights; defaults to uniform weights (1/N).\npattern (optional): Element radiation pattern; defaults to isotropic pattern in the θ-direction.\n\nReturns\n\nA URA instance with 3D element coordinates centered around the origin.\n\nExample\n\nusing PhasedArrays\nf = 10e9\nλ = 3e8/f\nura = URA(\"xy\", 4, 4, 0.5λ, 0.5λ)\n\n\n\n\n\n","category":"type"},{"location":"#PhasedArrays.URA-2","page":"Home","title":"PhasedArrays.URA","text":"URA\n\nUniform Rectangular Array (URA) of antenna elements.\n\nFields\n\nplane::String: The Cartesian plane in which the array lies. Must be \"xy\", \"xz\", or \"yz\".\nN1::Int64: Number of elements along the first axis of the plane.\nN2::Int64: Number of elements along the second axis of the plane.\nd1::Float64: Element spacing along the first axis (in meters).\nd2::Float64: Element spacing along the second axis (in meters).\nweights: Complex excitation weights for each element (e.g., a vector of ComplexF64 values).\nelement_pattern::ElementPattern: Radiation pattern of the element.\n\nDescription\n\nThe URA type represents a uniform rectangular antenna array, constructed in one of the three primary Cartesian planes. It supports arbitrary element weights and customizable radiation patterns.\n\nExample use:\n\nusing PhasedArrays\nf = 3e9\nλ = 3e8/f\ndx = 0.5*λ\ndy = 0.25*λ\nN = 5\nura = URA(\"xy\",N,N,dx,dy)\n\n\n\n\n\n","category":"type"},{"location":"#PhasedArrays.HansenWoodyardArray-Tuple{Char, Int64, Any}","page":"Home","title":"PhasedArrays.HansenWoodyardArray","text":"HansenWoodyardArray(axis::Char, N::Int, freq::Float64) -> ULA\n\nConstructs a Hansen-Woodyard endfire linear array along the specified axis.\n\nArguments\n\naxis: Array orientation; must be one of 'x', 'y', or 'z'.\nN: Number of antenna elements.\nfreq: Operating frequency in Hz.\n\nReturns\n\nA ULA object with Hansen-Woodyard spacing and weights that steer the beam toward the endfire direction.\n\nNotes\n\nSpacing is set to λ/2 * (1 - 1/N) for enhanced endfire directivity.\nThe beam is steered to:\nθ=90°, ϕ=0° for 'x'-axis\nθ=90°, ϕ=90° for 'y'-axis\nθ=0° for 'z'-axis\n\nExample\n\narray = HansenWoodyardArray('y', 10, 3e9)\n\n\n\n\n\n","category":"method"},{"location":"#PhasedArrays.Radial_bartlett_hann_window-Tuple{Any}","page":"Home","title":"PhasedArrays.Radial_bartlett_hann_window","text":"Radial_bartlett_hann_window(r::Float64)\n\nReturns Bartlett-Hann window evaluated at normalized radius r.\n\nHybrid taper with smoother roll-off and moderate sidelobe control.\n\n\n\n\n\n","category":"method"},{"location":"#PhasedArrays.apply_radial_taper!-Tuple{URA, Function, Any}","page":"Home","title":"PhasedArrays.apply_radial_taper!","text":"apply_radial_taper!(array::URA, taper_fun::Function, n::Int)\n\nApplies a radial taper to the weights of a URA array in-place.\n\nArguments\n\narray: A URA (Uniform Rectangular Array) whose weights will be modified.\ntaper_fun: A function mapping normalized radius ∈ [0, 1] to a taper value.\nn: Number of outer radial rings (based on unique distance levels) to suppress fully (i.e., taper to zero).\n\nBehavior\n\nComputes distance of each element from array center.\nApplies taper based on normalized radius r/r_max, where r_max is the distance to the n-th inner ring.\nWeights are multiplied by the taper and normalized.\n\nExample\n\napply_radial_taper!(ura, radial_hann_window, 1)\n\n\n\n\n\n","category":"method"},{"location":"#PhasedArrays.apply_taper_2D!-Tuple{URA, Any, Any}","page":"Home","title":"PhasedArrays.apply_taper_2D!","text":"apply_taper_2D!(array::URA, taper::Function, axis::Symbol)\n\nApplies a 2D tapering function (with separable kernels) to the weights of a uniform rectangular array (URA).\n\nArguments\n\narray: A URA instance whose weights will be modified in-place.\ntaper: A function that takes an integer N and returns a vector of length N representing the taper weights along one dimension.\naxis: Specifies which dimensions to apply the taper on.  \n:dim1 applies taper along the first axis.  \n:dim2 applies taper along the second axis.  \n:both applies same taper on both axes.\n\nBehavior\n\nThe function constructs a 2D taper weight matrix by taking the outer product of the taper vectors along each dimension.   It multiplies the existing weights element-wise by this taper matrix and then normalizes the resulting weights so that the sum of their absolute values is 1.\n\nNotes\n\nThe weights field of array is updated in-place.\nThe function assumes the weights vector can be reshaped into (N1, N2), where N1 and N2 are the array dimensions.\n\nExample\n\ntukey = N -> linear_tukey_window(N, 0.5)  # Example taper function\napply_taper_2D!(ura, tukey, :both)\n\n\n\n\n\n","category":"method"},{"location":"#PhasedArrays.flattop-Tuple{Any}","page":"Home","title":"PhasedArrays.flattop","text":"flattop(HalfWidth)\n\nReturns a function u -> 1 or 0, representing a flat-top beam pattern of given half-width (in degrees).\n\nArguments\n\nHalfWidth: Angular half-width of the flat region in degrees.\n\nReturns\n\nFunction defined on directional cosine u = cos(θ), with 1 inside the main lobe and 0 outside.\n\n\n\n\n\n","category":"method"},{"location":"#PhasedArrays.gaussian_pattern-Tuple{Any}","page":"Home","title":"PhasedArrays.gaussian_pattern","text":"gaussian_pattern(σ)\n\nReturns a Gaussian-shaped pattern in the directional cosine domain.\n\nArguments\n\nσ: Standard deviation controlling the width of the main lobe.\n\nReturns\n\nA function u -> exp(-u^2 / (2σ^2)) for smooth, bell-shaped beam shaping.\n\n\n\n\n\n","category":"method"},{"location":"#PhasedArrays.least_squares_synthesis-Tuple{Any, Any, Any, Function}","page":"Home","title":"PhasedArrays.least_squares_synthesis","text":"least_squares_synthesis(N, d, λ, Bd; θrange=0.0:0.1:180.0) -> Vector{ComplexF64}\n\nComputes array weights using least-squares pattern synthesis.\n\nArguments\n\nN: Number of elements.\nd: Element spacing.\nλ: Wavelength.\nBd: Desired pattern as a function of u = cos(θ).\nθrange: Angle range in degrees over which the pattern is matched (default: 0.0:0.1:180.0).\n\nReturns\n\nWeight vector that minimizes the squared error between the desired and actual beam pattern.\n\n\n\n\n\n","category":"method"},{"location":"#PhasedArrays.linear_bartlett_hann_window-Tuple{Any}","page":"Home","title":"PhasedArrays.linear_bartlett_hann_window","text":"linear_bartlett_hann_window(N)\n\nReturns a normalized Bartlett-Hann window of length N. Normalized to peak 1.\n\n\n\n\n\n","category":"method"},{"location":"#PhasedArrays.linear_blackman_harris_window-Tuple{Any}","page":"Home","title":"PhasedArrays.linear_blackman_harris_window","text":"linear_blackman_harris_window(N)\n\nReturns a normalized Blackman-Harris window of length N.\n\nHigh sidelobe suppression, typically better than standard Blackman. Normalized to 1.\n\n\n\n\n\n","category":"method"},{"location":"#PhasedArrays.linear_blackman_window-Tuple{Any}","page":"Home","title":"PhasedArrays.linear_blackman_window","text":"linear_blackman_window(N)\n\nReturns a normalized Blackman window of length N.\n\nProvides good sidelobe suppression at the cost of wider mainlobe. Normalized to peak 1.\n\n\n\n\n\n","category":"method"},{"location":"#PhasedArrays.linear_dolph_cheb_window-NTuple{4, Any}","page":"Home","title":"PhasedArrays.linear_dolph_cheb_window","text":"linear_dolph_cheb_window(N, R, d, λ)\n\nComputes Dolph-Chebyshev window of length N for a ULA with element spacing d and wavelength λ.\n\nArguments\n\nR: Desired sidelobe level in dB (e.g. -20).\nd: Element spacing in meters.\nλ: Wavelength in meters.\n\nReturns a real-valued weight vector normalized to unit gain in the endfire direction.\n\n\n\n\n\n","category":"method"},{"location":"#PhasedArrays.linear_gaussian_window-Tuple{Any, Any}","page":"Home","title":"PhasedArrays.linear_gaussian_window","text":"linear_gaussian_window(N, σ)\n\nReturns a normalized Gaussian window of length N with spread parameter σ.\n\nsmaller σ results in wider mainlobe and lower sidelobes. Normalized to peak 1.\n\n\n\n\n\n","category":"method"},{"location":"#PhasedArrays.linear_hamming_window-Tuple{Any}","page":"Home","title":"PhasedArrays.linear_hamming_window","text":"linear_hamming_window(N)\n\nReturns a normalized Hamming window of length N.\n\nUsed to taper array weights to reduce sidelobe levels. The window is normalized to have maximum value 1.\n\n\n\n\n\n","category":"method"},{"location":"#PhasedArrays.linear_hann_window-Tuple{Any}","page":"Home","title":"PhasedArrays.linear_hann_window","text":"linear_hann_window(N)\n\nReturns a normalized Hann window of length N.\n\nA cosine-based taper that reduces sidelobes. Maximum value is normalized to 1.\n\n\n\n\n\n","category":"method"},{"location":"#PhasedArrays.linear_kaiser_window-Tuple{Any, Any}","page":"Home","title":"PhasedArrays.linear_kaiser_window","text":"linear_kaiser_window(N, β)\n\nReturns a normalized Kaiser window of length N with shape parameter β.\n\nUseful for controlling sidelobe levels via β. Normalized to peak 1.\n\n\n\n\n\n","category":"method"},{"location":"#PhasedArrays.linear_taylor_window-NTuple{5, Any}","page":"Home","title":"PhasedArrays.linear_taylor_window","text":"linear_taylor_window(N, R, n̄, d, λ)\n\nGenerates a Taylor window with N elements, sidelobe level R (dB), and n̄ equal-level sidelobes.\n\nArguments\n\nR: Desired sidelobe level in dB (for example -20).\nn̄: Number of equal sidelobes + 1. Must be between 1 and N–1.\nd: Element spacing in meters.\nλ: Wavelength in meters.\n\nReturns a real-valued taper optimized for sidelobe control in antenna arrays.\n\n\n\n\n\n","category":"method"},{"location":"#PhasedArrays.linear_tukey_window-Tuple{Any, Any}","page":"Home","title":"PhasedArrays.linear_tukey_window","text":"linear_tukey_window(N, α)\n\nReturns a normalized Tukey (tapered cosine) window of length N with tapering parameter α ∈ [0, 1].\n\nα = 0 → rectangular window\nα = 1 → Hann window\n\nNormalized to maximum value 1.\n\n\n\n\n\n","category":"method"},{"location":"#PhasedArrays.radial_blackman_harris_window-Tuple{Any}","page":"Home","title":"PhasedArrays.radial_blackman_harris_window","text":"radial_blackman_harris_window(r::Float64)\n\nReturns Blackman-Harris window at normalized radius r.\n\n\n\n\n\n","category":"method"},{"location":"#PhasedArrays.radial_blackman_window-Tuple{Any}","page":"Home","title":"PhasedArrays.radial_blackman_window","text":"radial_blackman_window(r::Float64)\n\nBlackman window evaluated at normalized radius r.\n\nProvides stronger sidelobe suppression than Hann or Hamming.\n\n\n\n\n\n","category":"method"},{"location":"#PhasedArrays.radial_hamming_window-Tuple{Any}","page":"Home","title":"PhasedArrays.radial_hamming_window","text":"radial_hamming_window(r::Float64)\n\nReturns the value of a Hamming window at normalized radius r.\n\nCommonly used for moderate sidelobe suppression in array tapering.\n\n\n\n\n\n","category":"method"},{"location":"#PhasedArrays.radial_hann_window-Tuple{Any}","page":"Home","title":"PhasedArrays.radial_hann_window","text":"radial_hann_window(r::Float64)\n\nReturns the value of a Hann window evaluated at normalized radius r ∈ [0, 1].\n\nUsed in radial tapers for circular or rectangular arrays.\n\n\n\n\n\n","category":"method"},{"location":"#PhasedArrays.radial_kaiser_window-Tuple{Any, Any}","page":"Home","title":"PhasedArrays.radial_kaiser_window","text":"radial_kaiser_window(r::Float64, β::Float64)\n\nReturns Kaiser window value at normalized radius r, with shape parameter β.\n\n\n\n\n\n","category":"method"},{"location":"#PhasedArrays.radial_tukey_window-Tuple{Any, Any}","page":"Home","title":"PhasedArrays.radial_tukey_window","text":"radial_tukey_window(r::Float64, α::Float64)\n\nReturns Tukey (tapered cosine) window value at normalized radius r, with tapering parameter α ∈ [0, 1].\n\nα = 0 gives rectangular window\nα = 1 gives Hann window\n\n\n\n\n\n","category":"method"},{"location":"#PhasedArrays.raised_cosine-Tuple{Any, Any}","page":"Home","title":"PhasedArrays.raised_cosine","text":"raised_cosine(HalfWidth, rolloff)\n\nReturns a function representing a raised-cosine-shaped beam pattern in the directional cosine domain.\n\nArguments\n\nHalfWidth: Half-width of the main lobe (in degrees).\nrolloff: Transition width (in directional cosine units).\n\nReturns\n\nA smooth beam pattern tapering from 1 to 0 around the edge of the flat region.\n\n\n\n\n\n","category":"method"},{"location":"#PhasedArrays.sinc_pattern-Tuple{Any}","page":"Home","title":"PhasedArrays.sinc_pattern","text":"sinc_pattern(scale)\n\nReturns a sinc-based beam shaping function.\n\nArguments\n\nscale: Controls the lobe spacing and width in the directional cosine domain.\n\nReturns\n\nA function u -> sinc(scale * u), centered at broadside.\n\n\n\n\n\n","category":"method"},{"location":"#PhasedArrays.woodward_sampling-NTuple{4, Any}","page":"Home","title":"PhasedArrays.woodward_sampling","text":"woodward_sampling(N, d, λ, goalPattern) -> Vector{ComplexF64}\n\nComputes array weights using Woodward (spatial) sampling method.\n\nArguments\n\nN: Number of elements.\nd: Element spacing (in meters).\nλ: Wavelength (in meters).\ngoalPattern: A function u -> desired pattern, where u = cos(θ) is the directional cosine.\n\nReturns\n\nComplex weight vector that approximates the desired pattern over sampled points.\n\n\n\n\n\n","category":"method"}]
}
